{
  "name": "Pyliaison",
  "tagline": "A mashup of pywrapper and EcsPython that attempts facilitate communication between python and c++11. ",
  "body": "# PyLiaison\r\n\r\nA library that easily allows users to embed python interpreters in C++ applications and facilitates data transfer to and from the interpreter.\r\n\r\n```C++\r\npyl::RunCmd( \"print('Hello from Python!')\" );\r\n```\r\n\r\n## Purpose\r\n\r\nThe purpose of this library is to allow for projects that make use of both dynamic and compiled code to obtain a balance between performance and iteration time. C++ code can be exposed to and driven by python scripts via the use of custom modules created at runtime, and python objects (including modules and functions) can be encapsulated into C++ objects for scripted interfaces and components. \r\n\r\nData can also be passed to and from the interpreter freely, and custom overloads can be written to convert python objects to C++ types or allocate python objects from C++ types. \r\n\r\n## Examples\r\n\r\nHere is a simple example that shows how you can communicate with the interpreter. The interpreter is initalized, and the main module is retrieved as a pyl::Object (a shared ptr type meant to mimic mutable python types.) \r\n\r\n```C++\r\n// Initialize the python interpreter\r\npyl::initialize();\r\n\r\n// Get the main module, which is stored as python object\r\npyl::Object obMain = pyl::GetMainModule()\r\n\r\n// The attributes of an object can be accessed freely via templated set and get functions.\r\n\r\n// Create a object in the module (an int named iVal)\r\nint iVal( 12345 );\r\nobMain.set_attr( \"iVal\", iVal );\r\n\r\n// Negate the value in python\r\npyl::RunCmd( \"iVal = -iVal\" );\r\n\r\n// Get the value and convert it to an int\r\nint iNegVal( 0 );\r\nobMain.get_attr( \"iVal\", iNegVal'\r\n\r\n// Shut down the interpreter\r\npyl::finalize();\r\n```\r\n\r\n### Modules\r\n\r\nCustom modules can be declared in C++. The modules can contain interfaces to functions, class definitions, and member functions that can be imported by the interpreter.\r\n\r\n```C++\r\n// We'll declare this function in a custom module\r\ndouble mycos( double d ) {\r\n    return cos( d );\r\n}\r\n\r\n// Define a module named pylFuncs\r\npyl::ModuleDef * pModDef = CreateMod( pylFuncs );\r\n\r\n// Add the Mycos function to the module\r\nAddFnToMod( pModDef, mycos );\r\n\r\n// Initialize the interpreter\r\npyl::initialize();\r\n\r\n//Import our module and invoke the function\r\npyl::RunCmd( \"import pylFuncs\" );\r\npyl::RunCmd( \"print('The cosine of 0 is', pylFuncs.Mycos(0.))\" );\r\n```\r\n\r\nLike real python modules, custom modules can be wrapped by a pyl::Object and manipulated like anything else. \r\n\r\n```C++\r\n// Get the os.path module as an pyl::Object, which is backed by a shared_ptr \r\npyl::RunCmd( \"from os import path\" );\r\npyl::Object obPathMod = pyl::GetMainModule().get_attr( \"path\" );\r\n\r\n// Invoke the abspath function on the current file, store value\r\nstd::string filePath;\r\nobPathMod.call(\"abspath\", __FILE__).convert(filePath);\r\n```\r\n\r\n### Functions and Scripts\r\nSuppose I write a script (in a file named script.py) with a function that delimits strings, returning the individual strings in a list:\r\n\r\n```python\r\n# script.py\r\ndef delimit(str, d):\r\n    return str.split(d)\r\n```\r\n    \r\nScripts can be loaded into pyl::Objects. Any object with a callable variable can be accessed by using a pyl::Object's call function. \r\n\r\n```C++\r\n// Load the script from disk into a pyl::Object\r\npyl::Object obScript = pyl::Object::from_script(\"script.py\");\r\n\r\n// We'll turn this sentence into a vector of words\r\nstd::string sentence = \"My name is john\";\r\nstd::vector<std::string> vWords;\r\n\r\n// Call the function, convert the return value into a vector of strings\r\nobScript.call(\"delimit\", sentence, \" \").convert(vWords);\r\n```\r\n\r\n### Objects and Classes\r\n    \r\nA pyl::Object is meant to behave similarly to a PyObject, which is the general purpose type used to contain just about every variable available within the python interpreter. They own a std::shared_ptr to the object, meaning the object will stay alive for as long as it is passed around (like a mutable python object.)\r\n\r\nIf I were to declare a Foo instance f in this script, I could store it in C++ inside a pyl::Object\r\n\r\n```python\r\n# Foo.py\r\nclass Foo:\r\n    def __init__(self):\r\n        pass\r\n        \r\n    def doSomething(self):\r\n        print('Something')\r\n        \r\nf = Foo()\r\n```\r\n\r\nThe object can be stored as a C++ variable or declared into another pyl::Object. \r\n\r\n```C++\r\n// Get the object from the script and store it in a pyl::Object\r\npyl::Object obFooInst = pyl::Object::from_script(\"Foo.py\").get_attr(\"f\");\r\n\r\n// Invoke a member function using the instance\r\nobFooInst.call(\"doSomething\");\r\n\r\n// Declare a reference to the original object in the main module\r\npyl::GetMainModule().set_attr(\"f\", obFooInst);\r\n```\r\n\r\nInstances of C++ structs and classes can also be exposed into the interpreter by reference.\r\nThe definitions of the object are stored in a custom module like so:\r\n\r\n```C++\r\n// The C++ Bar class definition\r\nclass Bar{\r\n    int x;\r\npublic:\r\n    Bar() : x(0) {}\r\n    void setX(int x) { this->x = x);\r\n    int getX() return { x);\r\n};\r\n\r\n// Create a pyl module\r\npyl::ModuleDef * pBarMod = CreateMod( pylBar );\r\n\r\n// Add the class definiiton and member functions\r\nAddClassDefToMod(pBarMod, Bar);\r\nAddMemFnTomod(pBarMod, setX, void, int);\r\nAddMemFnTomod(pBarMod, getX, int);\r\n\r\n// Now I can use the module definition to declare\r\n// wrapper variable to a Bar instance named cppBar\r\nBar B;\r\npBarMod->Expose_Object(\"cppBar\", B);\r\n```\r\n\r\nWith the Bar instance B exposed into the interpreter,\r\nI can execute the following python code\r\n\r\n```python\r\n# In some python environment\r\nx = cppBar.getX()\r\ncppBar.setX(1)\r\n```\r\n\r\nThe cppBar variable is tied to the Bar instance B that we exposed,\r\nand will be valid as long as that instance's address is valid.\r\n\r\nC++ class instances can also be exposed via their pointer\r\n\r\n```C++\r\n// Expose a pointer to Bar instance B into the main module\r\npyl::GetMainModule.set_attr(\"ptrBar\", &B);\r\n\r\n// Assuming the Bar class definition has been imported, \r\n// the wrapper variable can be declared\r\npyl::RunCmd(\"cppB = pylBar.Bar(ptrB\");\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}