{
  "name": "Pyliaison",
  "tagline": "A mashup of pywrapper and EcsPython that attempts facilitate communication between python and c++11. ",
  "body": "# PyLiaison\r\n\r\nA library that easily allows users to embed python interpreters in C++ applications and facilitates data transfer to and from the interpreter.\r\n\r\n`pyl::RunCmd( \"print('Hello from Python!')\" );`\r\n\r\n## Examples\r\n\r\nHere is a simple example that shows how you can communicate with the interpreter. The interpreter is initalized, and the main module is retrieved as a pyl::Object (a shared ptr type meant to mimic mutable python types.) \r\n\r\n    // Initialize the python interpreter\r\n    pyl::initialize();\r\n\r\n    // Get the main module, which is stored as python object\r\n    pyl::Object obMain = pyl::GetMainModule()\r\n\r\nThe attrdict of an object can be accessed freely via templated set and get functions.\r\n\r\n    // Create a object in the module (an int named iVal)\r\n    int iVal( 12345 );\r\n    obMain.set_attr( \"iVal\", iVal );\r\n\r\n    // Negate the value in python\r\n    pyl::RunCmd( \"iVal = -iVal\" );\r\n\r\n    // Get the value and convert it to an int\r\n    int iNegVal( 0 );\r\n    obMain.get_attr( \"iVal\", iNegVal'\r\n\r\nFinalizing the interpreter\r\n\r\n    // Shut down the interpreter\r\n    pyl::finalize();\r\n    \r\n### Modules\r\n\r\nCustom modules can be declared in C++. The modules can contain interfaces to functions, class definitions, and member functions that can be imported by the interpreter.\r\n\r\n    // We'll declare this function in a custom module\r\n    double mycos( double d ) {\r\n        return cos( d );\r\n    }\r\n\r\n    // Define a module named pylFuncs\r\n    pyl::ModuleDef * pModDef = CreateMod( pylFuncs );\r\n\r\n    // Add the Mycos function to the module\r\n    AddFnToMod( pModDef, mycos );\r\n\r\n    // Initialize the interpreter\r\n    pyl::initialize();\r\n\r\n    //Import our module and invoke the function\r\n    pyl::RunCmd( \"import pylFuncs\" );\r\n    pyl::RunCmd( \"print('The cosine of 0 is', pylFuncs.Mycos(0.))\" );\r\n    \r\nLike real python modules, custom modules can be wrapped by a pyl::Object and manipulated like anything else. \r\n\r\n    // Get the os.path module as an pyl::Object, which is backed by a shared_ptr \r\n    pyl::RunCmd( \"from os import path\" );\r\n    pyl::Object obPathMod = pyl::GetMainModule().get_attr( \"path\" );\r\n\r\n    // Invoke the abspath function on the current file, store value\r\n    std::string filePath;\r\n    obPathMod.call(\"abspath\", __FILE__).convert(filePath);\r\n    \r\n### Functions and Scripts\r\nSuppose I write a script (in a file named script.py) with a function that delimits strings, returning the individual strings in a list:\r\n\r\n    # script.py\r\n    def delimit(str, d):\r\n        return str.split(d)\r\n    \r\nScripts can be loaded into pyl::Objects. Any object with a callable variable can be accessed by using a pyl::Object's call function. \r\n\r\n    // Load the script from disk into a pyl::Object\r\n    pyl::Object obScript = pyl::Object::from_script(\"script.py\");\r\n\r\n    // We'll turn this sentence into a vector of words\r\n    std::string sentence = \"My name is john\";\r\n    std::vector<std::string> vWords;\r\n\r\n    // Call the function, convert the return value into a vector of strings\r\n    obScript.call(\"delimit\", sentence, \" \").convert(vWords);\r\n\r\n### Objects and Classes\r\n    \r\nA pyl::Object is meant to behave similarly to a PyObject, which is the general purpose type used to contain just about every variable available within the python interpreter. They own a std::shared_ptr to the object, meaning the object will stay alive for as long as it is passed around (like a mutable python object.)\r\n\r\nIf I were to declare a Foo instance f in this script, I could store it in C++ inside a pyl::Object\r\n\r\n    # Foo.py\r\n    class Foo:\r\n        def __init__(self):\r\n            pass\r\n            \r\n        def doSomething(self):\r\n            print('Something')\r\n            \r\n    f = Foo()\r\n\r\nThe object can be stored as a C++ variable or declared into another pyl::Object. \r\n\r\n    // Get the object from the script and store it in a pyl::Object\r\n    pyl::Object obFooInst = pyl::Object::from_script(\"Foo.py\").get_attr(\"f\");\r\n\r\n    // Invoke a member function using the instance\r\n    obFooInst.call(\"doSomething\");\r\n\r\n    // Declare a reference to the original object in the main module\r\n    pyl::GetMainModule().set_attr(\"f\", obFooInst);\r\n    \r\nInstances of C++ structs and classes can also be exposed into the interpreter by reference.\r\nThe definitions of the object are stored in a custom module like so:\r\n\r\n    // The C++ Bar class definition\r\n    class Bar{\r\n        int x;\r\n    public:\r\n        Bar() : x(0) {}\r\n        void setX(int x) { this->x = x);\r\n        int getX() return { x);\r\n    };\r\n\r\n    // Create a pyl module\r\n    pyl::ModuleDef * pBarMod = CreateMod( pylBar );\r\n\r\n    // Add the class definiiton and member functions\r\n    AddClassDefToMod(pBarMod, Bar);\r\n    AddMemFnTomod(pBarMod, setX, void, int);\r\n    AddMemFnTomod(pBarMod, getX, int);\r\n\r\n    // Now I can use the module definition to declare\r\n    // wrapper variable to a Bar instance named cppBar\r\n    Bar B;\r\n    pBarMod->Expose_Object(\"cppBar\", B);\r\n\r\nWith the Bar instance B exposed into the interpreter,\r\nI can execute the following python code\r\n\r\n    x = cppBar.getX()\r\n    cppBar.setX(1)\r\n\r\nThe cppBar variable is tied to the Bar instance B that we exposed,\r\nand will be valid as long as that instance's address is valid.\r\n\r\nC++ class instances can also be exposed via their pointer\r\n\r\n    // Expose a pointer to Bar instance B into the main module\r\n    pyl::GetMainModule.set_attr(\"ptrBar\", &B);\r\n\r\n    // Assuming the Bar class definition has been imported, \r\n    // the wrapper variable can be declared\r\n    pyl::RunCmd(\"cppB = pylBar.Bar(ptrB\");\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}