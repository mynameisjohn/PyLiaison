<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Pyliaison by mynameisjohn</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Pyliaison</h1>
        <p>A mashup of pywrapper and EcsPython that attempts facilitate communication between python and c++11. </p>

        <p class="view"><a href="https://github.com/mynameisjohn/PyLiaison">View the Project on GitHub <small>mynameisjohn/PyLiaison</small></a></p>


        <ul>
          <li><a href="https://github.com/mynameisjohn/PyLiaison/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/mynameisjohn/PyLiaison/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/mynameisjohn/PyLiaison">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="pyliaison" class="anchor" href="#pyliaison" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PyLiaison</h1>

<p>A library that easily allows users to embed python interpreters in C++ applications and facilitates data transfer to and from the interpreter.</p>

<p><code>pyl::RunCmd( "print('Hello from Python!')" );</code></p>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Examples</h2>

<p>Here is a simple example that shows how you can communicate with the interpreter. The interpreter is initalized, and the main module is retrieved as a pyl::Object (a shared ptr type meant to mimic mutable python types.) </p>

<pre><code>// Initialize the python interpreter
pyl::initialize();

// Get the main module, which is stored as python object
pyl::Object obMain = pyl::GetMainModule()
</code></pre>

<p>The attrdict of an object can be accessed freely via templated set and get functions.</p>

<pre><code>// Create a object in the module (an int named iVal)
int iVal( 12345 );
obMain.set_attr( "iVal", iVal );

// Negate the value in python
pyl::RunCmd( "iVal = -iVal" );

// Get the value and convert it to an int
int iNegVal( 0 );
obMain.get_attr( "iVal", iNegVal'
</code></pre>

<p>Finalizing the interpreter</p>

<pre><code>// Shut down the interpreter
pyl::finalize();
</code></pre>

<h3>
<a id="modules" class="anchor" href="#modules" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Modules</h3>

<p>Custom modules can be declared in C++. The modules can contain interfaces to functions, class definitions, and member functions that can be imported by the interpreter.</p>

<pre><code>// We'll declare this function in a custom module
double mycos( double d ) {
    return cos( d );
}

// Define a module named pylFuncs
pyl::ModuleDef * pModDef = CreateMod( pylFuncs );

// Add the Mycos function to the module
AddFnToMod( pModDef, mycos );

// Initialize the interpreter
pyl::initialize();

//Import our module and invoke the function
pyl::RunCmd( "import pylFuncs" );
pyl::RunCmd( "print('The cosine of 0 is', pylFuncs.Mycos(0.))" );
</code></pre>

<p>Like real python modules, custom modules can be wrapped by a pyl::Object and manipulated like anything else. </p>

<pre><code>// Get the os.path module as an pyl::Object, which is backed by a shared_ptr 
pyl::RunCmd( "from os import path" );
pyl::Object obPathMod = pyl::GetMainModule().get_attr( "path" );

// Invoke the abspath function on the current file, store value
std::string filePath;
obPathMod.call("abspath", __FILE__).convert(filePath);
</code></pre>

<h3>
<a id="functions-and-scripts" class="anchor" href="#functions-and-scripts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Functions and Scripts</h3>

<p>Suppose I write a script (in a file named script.py) with a function that delimits strings, returning the individual strings in a list:</p>

<pre><code># script.py
def delimit(str, d):
    return str.split(d)
</code></pre>

<p>Scripts can be loaded into pyl::Objects. Any object with a callable variable can be accessed by using a pyl::Object's call function. </p>

<pre><code>// Load the script from disk into a pyl::Object
pyl::Object obScript = pyl::Object::from_script("script.py");

// We'll turn this sentence into a vector of words
std::string sentence = "My name is john";
std::vector&lt;std::string&gt; vWords;

// Call the function, convert the return value into a vector of strings
obScript.call("delimit", sentence, " ").convert(vWords);
</code></pre>

<h3>
<a id="objects-and-classes" class="anchor" href="#objects-and-classes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Objects and Classes</h3>

<p>A pyl::Object is meant to behave similarly to a PyObject, which is the general purpose type used to contain just about every variable available within the python interpreter. They own a std::shared_ptr to the object, meaning the object will stay alive for as long as it is passed around (like a mutable python object.)</p>

<p>If I were to declare a Foo instance f in this script, I could store it in C++ inside a pyl::Object</p>

<pre><code># Foo.py
class Foo:
    def __init__(self):
        pass

    def doSomething(self):
        print('Something')

f = Foo()
</code></pre>

<p>The object can be stored as a C++ variable or declared into another pyl::Object. </p>

<pre><code>// Get the object from the script and store it in a pyl::Object
pyl::Object obFooInst = pyl::Object::from_script("Foo.py").get_attr("f");

// Invoke a member function using the instance
obFooInst.call("doSomething");

// Declare a reference to the original object in the main module
pyl::GetMainModule().set_attr("f", obFooInst);
</code></pre>

<p>Instances of C++ structs and classes can also be exposed into the interpreter by reference.
The definitions of the object are stored in a custom module like so:</p>

<pre><code>// The C++ Bar class definition
class Bar{
    int x;
public:
    Bar() : x(0) {}
    void setX(int x) { this-&gt;x = x);
    int getX() return { x);
};

// Create a pyl module
pyl::ModuleDef * pBarMod = CreateMod( pylBar );

// Add the class definiiton and member functions
AddClassDefToMod(pBarMod, Bar);
AddMemFnTomod(pBarMod, setX, void, int);
AddMemFnTomod(pBarMod, getX, int);

// Now I can use the module definition to declare
// wrapper variable to a Bar instance named cppBar
Bar B;
pBarMod-&gt;Expose_Object("cppBar", B);
</code></pre>

<p>With the Bar instance B exposed into the interpreter,
I can execute the following python code</p>

<pre><code>x = cppBar.getX()
cppBar.setX(1)
</code></pre>

<p>The cppBar variable is tied to the Bar instance B that we exposed,
and will be valid as long as that instance's address is valid.</p>

<p>C++ class instances can also be exposed via their pointer</p>

<pre><code>// Expose a pointer to Bar instance B into the main module
pyl::GetMainModule.set_attr("ptrBar", &amp;B);

// Assuming the Bar class definition has been imported, 
// the wrapper variable can be declared
pyl::RunCmd("cppB = pylBar.Bar(ptrB");
</code></pre>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/mynameisjohn">mynameisjohn</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
